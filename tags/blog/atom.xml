<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>Alex Cameron - blog</title>
    <link rel="self" type="application/atom+xml" href="https://tetsuo.sh/tags/blog/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://tetsuo.sh"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2024-01-31T00:00:00+00:00</updated>
    <id>https://tetsuo.sh/tags/blog/atom.xml</id>
    <entry xml:lang="en">
        <title>New year, new blog</title>
        <published>2024-01-31T00:00:00+00:00</published>
        <updated>2024-01-31T00:00:00+00:00</updated>
        
        <author>
          <name>
            Alex Cameron
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://tetsuo.sh/post/new-blog/"/>
        <id>https://tetsuo.sh/post/new-blog/</id>
        
        <content type="html" xml:base="https://tetsuo.sh/post/new-blog/">&lt;p&gt;One of my New Year&#x27;s Resolutions for 2024 was to start a technical blog.
Since it&#x27;s already the last day of January and I&#x27;ve yet to write anything, I felt obliged to kick things off with an introductory post describing what I&#x27;m intending to write about as well as some guiding principles that I have in mind.&lt;&#x2F;p&gt;
&lt;p&gt;If any of this sounds interesting to you, please bookmark my blog or add &lt;a href=&quot;&#x2F;atom.xml&quot;&gt;my feed&lt;&#x2F;a&gt; to your RSS reader to keep up to date!&lt;&#x2F;p&gt;
&lt;h1 id=&quot;ideas&quot;&gt;Ideas&lt;&#x2F;h1&gt;
&lt;p&gt;In a few weeks, I&#x27;ll be beginning a new job working on a software stack for a chip designed to accelerate cryptographic workloads (in particular, &lt;abbr title=&quot;Zero Knowledge Proofs&quot;&gt;ZKP&lt;&#x2F;abbr&gt; and &lt;abbr title=&quot;Fully Homomorphic Encryption&quot;&gt;FHE&lt;&#x2F;abbr&gt;).
This is another step in a journey that I&#x27;ve been on since 2019 to become a compilers specialist.&lt;&#x2F;p&gt;
&lt;p&gt;Naturally, I&#x27;m planning to document some of the skills that I have to learn on the job.
Aside from general compiler knowledge, this will involve diving deeper into cryptography and mathematics.&lt;&#x2F;p&gt;
&lt;p&gt;I&#x27;d also like to write some more industry focused content about what compiler jobs are available, how someone might go about getting one of these jobs and perhaps talk a bit about my own experience attempting to make this transition from a generalist systems programmer to a compilers specialist.
Given how niche these jobs are, there understandably isn&#x27;t a great deal written on this topic so it can feel daunting to figure this all out yourself.&lt;&#x2F;p&gt;
&lt;p&gt;More generally, I love to learn how things work under the hood and I suspect that this is a large part of why I&#x27;m drawn to low-level programming to begin with.
Apart from compilers and runtimes, there are a lot of different types of software that I&#x27;d like to understand on a deeper level: debuggers, linkers, compression algorithms, fuzzers, etc.
I&#x27;d like to be able to describe what makes them tick and how someone would go about building one themselves, ideally accompanied by a GitHub repo with working code.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;principles&quot;&gt;Principles&lt;&#x2F;h1&gt;
&lt;p&gt;When it comes to learning how to build computer programs, I believe that the most important thing is to be prolific.
As I was starting out in the industry, I wasted a lot of time bike-shedding on personal projects and trying to figure out the optimal way to design a given piece of code.
The reality is that the time I spent didn&#x27;t improve the code much as I simply &lt;strong&gt;didn&#x27;t know&lt;&#x2F;strong&gt; how to design software and that, even with unlimited time, I probably wouldn&#x27;t have arrived at a good solution.
I&#x27;m now of the opinion that it&#x27;s more important to just churn it out, get as much experience as possible and observe firsthand what works well and what doesn&#x27;t.&lt;&#x2F;p&gt;
&lt;p&gt;I&#x27;m trying to apply this philosophy to writing as well. That is, prioritise writing frequently over obsessing about the form, and be at peace with the fact that my writing won&#x27;t be great at first.
My hope is that by writing consistently, producing quality writing will start to feel normal and become part of my modus operandi.&lt;&#x2F;p&gt;
&lt;p&gt;Another principle that I want to stick to is to write in an approachable way that is understandable by the working programmer.
One of the difficulties I had learning about compilers was that most learning materials are couched in academic language.
I&#x27;d like to write in a common sense way that makes these topics feel more friendly and do my part to perhaps dispel some of the mystique around compilers and programming languages.&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>
